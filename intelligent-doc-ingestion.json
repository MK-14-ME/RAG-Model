{
  "name": "Photonics RAG Ingestion & Retrieval Workflow",
  "nodes": [
    {
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-752, 304],
      "parameters": {}
    },

    {
      "id": "gdrive-search",
      "name": "Google Drive – Search File",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [-528, 160],
      "alwaysOutputData": true,
      "parameters": {
        "resource": "fileFolder",
        "searchMethod": "query",
        "queryString": "name = 'ADD_YOUR_FILENAME.pdf'",
        "filter": {},
        "options": {}
      },
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "<ADD_GOOGLE_DRIVE_CREDENTIAL_ID>",
          "name": "Google Drive OAuth Credential"
        }
      }
    },

    {
      "id": "gdrive-download",
      "name": "Google Drive – Download File",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [-304, 160],
      "parameters": {
        "operation": "download",
        "fileId": "={{ $json[\"id\"] }}",
        "options": {
          "binaryPropertyName": "binary"
        }
      },
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "<ADD_GOOGLE_DRIVE_CREDENTIAL_ID>",
          "name": "Google Drive OAuth Credential"
        }
      }
    },

    {
      "id": "file-extract",
      "name": "Extract Text from PDF",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [-16, 160],
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "binary",
        "options": {}
      }
    },

    {
      "id": "text-splitter",
      "name": "Code – Text Splitter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [272, 160],
      "parameters": {
        "jsCode": "// Splits extracted text into chunks for embedding\nconst text = $json[\"text\"];\nconst chunkSize = 1500;\nconst overlap = 200;\nconst chunks = [];\n\nfor (let start = 0; start < text.length; start += (chunkSize - overlap)) {\n  const end = Math.min(start + chunkSize, text.length);\n  chunks.push({ chunk: text.slice(start, end), chunk_id: chunks.length });\n}\n\nreturn chunks.map(c => ({ json: c }));"
      }
    },

    {
      "id": "format-embedding-payload",
      "name": "Code – Format Embedding Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [560, 80],
      "parameters": {
        "jsCode": "const items = $input.all();\n\nconst requests = items.map((item, index) => ({\n  model: \"models/text-embedding-004\",\n  content: {\n    parts: [{ text: item.json.chunk }]\n  }\n}));\n\nreturn items.map((item, index) => ({\n  json: { chunk: item.json.chunk, chunk_id: index, requests }\n}));"
      }
    },

    {
      "id": "gemini-embed",
      "name": "Gemini – Batch Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [848, 80],
      "parameters": {
        "method": "POST",
        "url": "<ADD_GEMINI_EMBEDDING_ENDPOINT>",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "=requests",
        "body": "={{ { \"requests\": $json.requests } }}"
      },
      "credentials": {
        "googlePalmApi": {
          "id": "<ADD_GEMINI_CREDENTIAL_ID>",
          "name": "Google Gemini API Credential"
        }
      }
    },

    {
      "id": "merge-node",
      "name": "Merge Chunks + Embeddings",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [1072, 160],
      "parameters": {}
    },

    {
      "id": "format-vectors",
      "name": "Code – Build Pinecone Vectors",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1296, 160],
      "alwaysOutputData": true,
      "parameters": {
        "jsCode": "// Combine chunks with embeddings into Pinecone vector format\nconst chunkTexts = [];\nconst embeddingVectors = [];\n\nfor (const item of items) {\n  const data = item.json;\n\n  if (data.chunk !== undefined) chunkTexts[data.chunk_id] = data.chunk;\n  else if (data.embeddings?.[0]?.values) embeddingVectors.push(data.embeddings[0].values);\n}\n\nif (chunkTexts.length !== embeddingVectors.length)\n  throw new Error(\"Mismatch between chunks and embeddings\");\n\nconst vectors = chunkTexts.map((txt, i) => ({\n  id: `chunk_${i}`,\n  values: embeddingVectors[i],\n  metadata: { text: txt, chunk_id: i, source: \"ADD_SOURCE_FILENAME\" }\n}));\n\nreturn [{ json: { vectors } }];"
      }
    },

    {
      "id": "pinecone-upsert",
      "name": "Pinecone – Upsert Vectors",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [1520, 160],
      "parameters": {
        "method": "POST",
        "url": "<ADD_PINECONE_UPSERT_URL>",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{ $json }}"
      },
      "credentials": {
        "httpHeaderAuth": {
          "id": "<ADD_PINECONE_API_KEY_ID>",
          "name": "Pinecone API Key"
        }
      }
    },

    {
      "id": "user-question",
      "name": "User Question",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-528, 448],
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "question",
              "value": "ADD_YOUR_QUESTION_HERE",
              "type": "string"
            }
          ]
        }
      }
    },

    {
      "id": "gemini-question-embedding",
      "name": "Gemini – Embed Question",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [-304, 448],
      "parameters": {
        "method": "POST",
        "url": "<ADD_GEMINI_SINGLE_EMBED_ENDPOINT>",
        "sendHeaders": true,
        "headerParameters": { "parameters": [{ "name": "Content-Type", "value": "application/json" }] },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={ \"content\": { \"parts\": [{ \"text\": \"{{$json.question}}\" }] } }"
      }
    }
  ],

  "connections": {},

  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": []
}
